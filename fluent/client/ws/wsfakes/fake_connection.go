// Code generated by counterfeiter. DO NOT EDIT.
package wsfakes

import (
	"io"
	"net"
	"sync"
	"time"

	"github.com/IBM/fluent-forward-go/fluent/client/ws"
	"github.com/gorilla/websocket"
)

type FakeConnection struct {
	CloseStub        func() error
	closeMutex       sync.RWMutex
	closeArgsForCall []struct {
	}
	closeReturns struct {
		result1 error
	}
	closeReturnsOnCall map[int]struct {
		result1 error
	}
	CloseHandlerStub        func() func(code int, text string) error
	closeHandlerMutex       sync.RWMutex
	closeHandlerArgsForCall []struct {
	}
	closeHandlerReturns struct {
		result1 func(code int, text string) error
	}
	closeHandlerReturnsOnCall map[int]struct {
		result1 func(code int, text string) error
	}
	CloseWithMsgStub        func(int, string) error
	closeWithMsgMutex       sync.RWMutex
	closeWithMsgArgsForCall []struct {
		arg1 int
		arg2 string
	}
	closeWithMsgReturns struct {
		result1 error
	}
	closeWithMsgReturnsOnCall map[int]struct {
		result1 error
	}
	ClosedStub        func() bool
	closedMutex       sync.RWMutex
	closedArgsForCall []struct {
	}
	closedReturns struct {
		result1 bool
	}
	closedReturnsOnCall map[int]struct {
		result1 bool
	}
	EnableWriteCompressionStub        func(bool)
	enableWriteCompressionMutex       sync.RWMutex
	enableWriteCompressionArgsForCall []struct {
		arg1 bool
	}
	ListenStub        func() error
	listenMutex       sync.RWMutex
	listenArgsForCall []struct {
	}
	listenReturns struct {
		result1 error
	}
	listenReturnsOnCall map[int]struct {
		result1 error
	}
	LocalAddrStub        func() net.Addr
	localAddrMutex       sync.RWMutex
	localAddrArgsForCall []struct {
	}
	localAddrReturns struct {
		result1 net.Addr
	}
	localAddrReturnsOnCall map[int]struct {
		result1 net.Addr
	}
	NextReaderStub        func() (int, io.Reader, error)
	nextReaderMutex       sync.RWMutex
	nextReaderArgsForCall []struct {
	}
	nextReaderReturns struct {
		result1 int
		result2 io.Reader
		result3 error
	}
	nextReaderReturnsOnCall map[int]struct {
		result1 int
		result2 io.Reader
		result3 error
	}
	NextWriterStub        func(int) (io.WriteCloser, error)
	nextWriterMutex       sync.RWMutex
	nextWriterArgsForCall []struct {
		arg1 int
	}
	nextWriterReturns struct {
		result1 io.WriteCloser
		result2 error
	}
	nextWriterReturnsOnCall map[int]struct {
		result1 io.WriteCloser
		result2 error
	}
	PingHandlerStub        func() func(appData string) error
	pingHandlerMutex       sync.RWMutex
	pingHandlerArgsForCall []struct {
	}
	pingHandlerReturns struct {
		result1 func(appData string) error
	}
	pingHandlerReturnsOnCall map[int]struct {
		result1 func(appData string) error
	}
	PongHandlerStub        func() func(appData string) error
	pongHandlerMutex       sync.RWMutex
	pongHandlerArgsForCall []struct {
	}
	pongHandlerReturns struct {
		result1 func(appData string) error
	}
	pongHandlerReturnsOnCall map[int]struct {
		result1 func(appData string) error
	}
	ReadHandlerStub        func() ws.ReadHandler
	readHandlerMutex       sync.RWMutex
	readHandlerArgsForCall []struct {
	}
	readHandlerReturns struct {
		result1 ws.ReadHandler
	}
	readHandlerReturnsOnCall map[int]struct {
		result1 ws.ReadHandler
	}
	ReadMessageStub        func() (int, []byte, error)
	readMessageMutex       sync.RWMutex
	readMessageArgsForCall []struct {
	}
	readMessageReturns struct {
		result1 int
		result2 []byte
		result3 error
	}
	readMessageReturnsOnCall map[int]struct {
		result1 int
		result2 []byte
		result3 error
	}
	RemoteAddrStub        func() net.Addr
	remoteAddrMutex       sync.RWMutex
	remoteAddrArgsForCall []struct {
	}
	remoteAddrReturns struct {
		result1 net.Addr
	}
	remoteAddrReturnsOnCall map[int]struct {
		result1 net.Addr
	}
	SetCloseHandlerStub        func(func(code int, text string) error)
	setCloseHandlerMutex       sync.RWMutex
	setCloseHandlerArgsForCall []struct {
		arg1 func(code int, text string) error
	}
	SetCompressionLevelStub        func(int) error
	setCompressionLevelMutex       sync.RWMutex
	setCompressionLevelArgsForCall []struct {
		arg1 int
	}
	setCompressionLevelReturns struct {
		result1 error
	}
	setCompressionLevelReturnsOnCall map[int]struct {
		result1 error
	}
	SetPingHandlerStub        func(func(appData string) error)
	setPingHandlerMutex       sync.RWMutex
	setPingHandlerArgsForCall []struct {
		arg1 func(appData string) error
	}
	SetPongHandlerStub        func(func(appData string) error)
	setPongHandlerMutex       sync.RWMutex
	setPongHandlerArgsForCall []struct {
		arg1 func(appData string) error
	}
	SetReadDeadlineStub        func(time.Time) error
	setReadDeadlineMutex       sync.RWMutex
	setReadDeadlineArgsForCall []struct {
		arg1 time.Time
	}
	setReadDeadlineReturns struct {
		result1 error
	}
	setReadDeadlineReturnsOnCall map[int]struct {
		result1 error
	}
	SetReadHandlerStub        func(ws.ReadHandler)
	setReadHandlerMutex       sync.RWMutex
	setReadHandlerArgsForCall []struct {
		arg1 ws.ReadHandler
	}
	SetReadLimitStub        func(int64)
	setReadLimitMutex       sync.RWMutex
	setReadLimitArgsForCall []struct {
		arg1 int64
	}
	SetWriteDeadlineStub        func(time.Time) error
	setWriteDeadlineMutex       sync.RWMutex
	setWriteDeadlineArgsForCall []struct {
		arg1 time.Time
	}
	setWriteDeadlineReturns struct {
		result1 error
	}
	setWriteDeadlineReturnsOnCall map[int]struct {
		result1 error
	}
	SubprotocolStub        func() string
	subprotocolMutex       sync.RWMutex
	subprotocolArgsForCall []struct {
	}
	subprotocolReturns struct {
		result1 string
	}
	subprotocolReturnsOnCall map[int]struct {
		result1 string
	}
	UnderlyingConnStub        func() net.Conn
	underlyingConnMutex       sync.RWMutex
	underlyingConnArgsForCall []struct {
	}
	underlyingConnReturns struct {
		result1 net.Conn
	}
	underlyingConnReturnsOnCall map[int]struct {
		result1 net.Conn
	}
	WriteStub        func([]byte) (int, error)
	writeMutex       sync.RWMutex
	writeArgsForCall []struct {
		arg1 []byte
	}
	writeReturns struct {
		result1 int
		result2 error
	}
	writeReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	WriteControlStub        func(int, []byte, time.Time) error
	writeControlMutex       sync.RWMutex
	writeControlArgsForCall []struct {
		arg1 int
		arg2 []byte
		arg3 time.Time
	}
	writeControlReturns struct {
		result1 error
	}
	writeControlReturnsOnCall map[int]struct {
		result1 error
	}
	WriteMessageStub        func(int, []byte) error
	writeMessageMutex       sync.RWMutex
	writeMessageArgsForCall []struct {
		arg1 int
		arg2 []byte
	}
	writeMessageReturns struct {
		result1 error
	}
	writeMessageReturnsOnCall map[int]struct {
		result1 error
	}
	WritePreparedMessageStub        func(*websocket.PreparedMessage) error
	writePreparedMessageMutex       sync.RWMutex
	writePreparedMessageArgsForCall []struct {
		arg1 *websocket.PreparedMessage
	}
	writePreparedMessageReturns struct {
		result1 error
	}
	writePreparedMessageReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeConnection) Close() error {
	fake.closeMutex.Lock()
	ret, specificReturn := fake.closeReturnsOnCall[len(fake.closeArgsForCall)]
	fake.closeArgsForCall = append(fake.closeArgsForCall, struct {
	}{})
	stub := fake.CloseStub
	fakeReturns := fake.closeReturns
	fake.recordInvocation("Close", []interface{}{})
	fake.closeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeConnection) CloseCallCount() int {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return len(fake.closeArgsForCall)
}

func (fake *FakeConnection) CloseCalls(stub func() error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = stub
}

func (fake *FakeConnection) CloseReturns(result1 error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = nil
	fake.closeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeConnection) CloseReturnsOnCall(i int, result1 error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = nil
	if fake.closeReturnsOnCall == nil {
		fake.closeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.closeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeConnection) CloseHandler() func(code int, text string) error {
	fake.closeHandlerMutex.Lock()
	ret, specificReturn := fake.closeHandlerReturnsOnCall[len(fake.closeHandlerArgsForCall)]
	fake.closeHandlerArgsForCall = append(fake.closeHandlerArgsForCall, struct {
	}{})
	stub := fake.CloseHandlerStub
	fakeReturns := fake.closeHandlerReturns
	fake.recordInvocation("CloseHandler", []interface{}{})
	fake.closeHandlerMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeConnection) CloseHandlerCallCount() int {
	fake.closeHandlerMutex.RLock()
	defer fake.closeHandlerMutex.RUnlock()
	return len(fake.closeHandlerArgsForCall)
}

func (fake *FakeConnection) CloseHandlerCalls(stub func() func(code int, text string) error) {
	fake.closeHandlerMutex.Lock()
	defer fake.closeHandlerMutex.Unlock()
	fake.CloseHandlerStub = stub
}

func (fake *FakeConnection) CloseHandlerReturns(result1 func(code int, text string) error) {
	fake.closeHandlerMutex.Lock()
	defer fake.closeHandlerMutex.Unlock()
	fake.CloseHandlerStub = nil
	fake.closeHandlerReturns = struct {
		result1 func(code int, text string) error
	}{result1}
}

func (fake *FakeConnection) CloseHandlerReturnsOnCall(i int, result1 func(code int, text string) error) {
	fake.closeHandlerMutex.Lock()
	defer fake.closeHandlerMutex.Unlock()
	fake.CloseHandlerStub = nil
	if fake.closeHandlerReturnsOnCall == nil {
		fake.closeHandlerReturnsOnCall = make(map[int]struct {
			result1 func(code int, text string) error
		})
	}
	fake.closeHandlerReturnsOnCall[i] = struct {
		result1 func(code int, text string) error
	}{result1}
}

func (fake *FakeConnection) CloseWithMsg(arg1 int, arg2 string) error {
	fake.closeWithMsgMutex.Lock()
	ret, specificReturn := fake.closeWithMsgReturnsOnCall[len(fake.closeWithMsgArgsForCall)]
	fake.closeWithMsgArgsForCall = append(fake.closeWithMsgArgsForCall, struct {
		arg1 int
		arg2 string
	}{arg1, arg2})
	stub := fake.CloseWithMsgStub
	fakeReturns := fake.closeWithMsgReturns
	fake.recordInvocation("CloseWithMsg", []interface{}{arg1, arg2})
	fake.closeWithMsgMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeConnection) CloseWithMsgCallCount() int {
	fake.closeWithMsgMutex.RLock()
	defer fake.closeWithMsgMutex.RUnlock()
	return len(fake.closeWithMsgArgsForCall)
}

func (fake *FakeConnection) CloseWithMsgCalls(stub func(int, string) error) {
	fake.closeWithMsgMutex.Lock()
	defer fake.closeWithMsgMutex.Unlock()
	fake.CloseWithMsgStub = stub
}

func (fake *FakeConnection) CloseWithMsgArgsForCall(i int) (int, string) {
	fake.closeWithMsgMutex.RLock()
	defer fake.closeWithMsgMutex.RUnlock()
	argsForCall := fake.closeWithMsgArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeConnection) CloseWithMsgReturns(result1 error) {
	fake.closeWithMsgMutex.Lock()
	defer fake.closeWithMsgMutex.Unlock()
	fake.CloseWithMsgStub = nil
	fake.closeWithMsgReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeConnection) CloseWithMsgReturnsOnCall(i int, result1 error) {
	fake.closeWithMsgMutex.Lock()
	defer fake.closeWithMsgMutex.Unlock()
	fake.CloseWithMsgStub = nil
	if fake.closeWithMsgReturnsOnCall == nil {
		fake.closeWithMsgReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.closeWithMsgReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeConnection) Closed() bool {
	fake.closedMutex.Lock()
	ret, specificReturn := fake.closedReturnsOnCall[len(fake.closedArgsForCall)]
	fake.closedArgsForCall = append(fake.closedArgsForCall, struct {
	}{})
	stub := fake.ClosedStub
	fakeReturns := fake.closedReturns
	fake.recordInvocation("Closed", []interface{}{})
	fake.closedMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeConnection) ClosedCallCount() int {
	fake.closedMutex.RLock()
	defer fake.closedMutex.RUnlock()
	return len(fake.closedArgsForCall)
}

func (fake *FakeConnection) ClosedCalls(stub func() bool) {
	fake.closedMutex.Lock()
	defer fake.closedMutex.Unlock()
	fake.ClosedStub = stub
}

func (fake *FakeConnection) ClosedReturns(result1 bool) {
	fake.closedMutex.Lock()
	defer fake.closedMutex.Unlock()
	fake.ClosedStub = nil
	fake.closedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeConnection) ClosedReturnsOnCall(i int, result1 bool) {
	fake.closedMutex.Lock()
	defer fake.closedMutex.Unlock()
	fake.ClosedStub = nil
	if fake.closedReturnsOnCall == nil {
		fake.closedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.closedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeConnection) EnableWriteCompression(arg1 bool) {
	fake.enableWriteCompressionMutex.Lock()
	fake.enableWriteCompressionArgsForCall = append(fake.enableWriteCompressionArgsForCall, struct {
		arg1 bool
	}{arg1})
	stub := fake.EnableWriteCompressionStub
	fake.recordInvocation("EnableWriteCompression", []interface{}{arg1})
	fake.enableWriteCompressionMutex.Unlock()
	if stub != nil {
		fake.EnableWriteCompressionStub(arg1)
	}
}

func (fake *FakeConnection) EnableWriteCompressionCallCount() int {
	fake.enableWriteCompressionMutex.RLock()
	defer fake.enableWriteCompressionMutex.RUnlock()
	return len(fake.enableWriteCompressionArgsForCall)
}

func (fake *FakeConnection) EnableWriteCompressionCalls(stub func(bool)) {
	fake.enableWriteCompressionMutex.Lock()
	defer fake.enableWriteCompressionMutex.Unlock()
	fake.EnableWriteCompressionStub = stub
}

func (fake *FakeConnection) EnableWriteCompressionArgsForCall(i int) bool {
	fake.enableWriteCompressionMutex.RLock()
	defer fake.enableWriteCompressionMutex.RUnlock()
	argsForCall := fake.enableWriteCompressionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeConnection) Listen() error {
	fake.listenMutex.Lock()
	ret, specificReturn := fake.listenReturnsOnCall[len(fake.listenArgsForCall)]
	fake.listenArgsForCall = append(fake.listenArgsForCall, struct {
	}{})
	stub := fake.ListenStub
	fakeReturns := fake.listenReturns
	fake.recordInvocation("Listen", []interface{}{})
	fake.listenMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeConnection) ListenCallCount() int {
	fake.listenMutex.RLock()
	defer fake.listenMutex.RUnlock()
	return len(fake.listenArgsForCall)
}

func (fake *FakeConnection) ListenCalls(stub func() error) {
	fake.listenMutex.Lock()
	defer fake.listenMutex.Unlock()
	fake.ListenStub = stub
}

func (fake *FakeConnection) ListenReturns(result1 error) {
	fake.listenMutex.Lock()
	defer fake.listenMutex.Unlock()
	fake.ListenStub = nil
	fake.listenReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeConnection) ListenReturnsOnCall(i int, result1 error) {
	fake.listenMutex.Lock()
	defer fake.listenMutex.Unlock()
	fake.ListenStub = nil
	if fake.listenReturnsOnCall == nil {
		fake.listenReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.listenReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeConnection) LocalAddr() net.Addr {
	fake.localAddrMutex.Lock()
	ret, specificReturn := fake.localAddrReturnsOnCall[len(fake.localAddrArgsForCall)]
	fake.localAddrArgsForCall = append(fake.localAddrArgsForCall, struct {
	}{})
	stub := fake.LocalAddrStub
	fakeReturns := fake.localAddrReturns
	fake.recordInvocation("LocalAddr", []interface{}{})
	fake.localAddrMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeConnection) LocalAddrCallCount() int {
	fake.localAddrMutex.RLock()
	defer fake.localAddrMutex.RUnlock()
	return len(fake.localAddrArgsForCall)
}

func (fake *FakeConnection) LocalAddrCalls(stub func() net.Addr) {
	fake.localAddrMutex.Lock()
	defer fake.localAddrMutex.Unlock()
	fake.LocalAddrStub = stub
}

func (fake *FakeConnection) LocalAddrReturns(result1 net.Addr) {
	fake.localAddrMutex.Lock()
	defer fake.localAddrMutex.Unlock()
	fake.LocalAddrStub = nil
	fake.localAddrReturns = struct {
		result1 net.Addr
	}{result1}
}

func (fake *FakeConnection) LocalAddrReturnsOnCall(i int, result1 net.Addr) {
	fake.localAddrMutex.Lock()
	defer fake.localAddrMutex.Unlock()
	fake.LocalAddrStub = nil
	if fake.localAddrReturnsOnCall == nil {
		fake.localAddrReturnsOnCall = make(map[int]struct {
			result1 net.Addr
		})
	}
	fake.localAddrReturnsOnCall[i] = struct {
		result1 net.Addr
	}{result1}
}

func (fake *FakeConnection) NextReader() (int, io.Reader, error) {
	fake.nextReaderMutex.Lock()
	ret, specificReturn := fake.nextReaderReturnsOnCall[len(fake.nextReaderArgsForCall)]
	fake.nextReaderArgsForCall = append(fake.nextReaderArgsForCall, struct {
	}{})
	stub := fake.NextReaderStub
	fakeReturns := fake.nextReaderReturns
	fake.recordInvocation("NextReader", []interface{}{})
	fake.nextReaderMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeConnection) NextReaderCallCount() int {
	fake.nextReaderMutex.RLock()
	defer fake.nextReaderMutex.RUnlock()
	return len(fake.nextReaderArgsForCall)
}

func (fake *FakeConnection) NextReaderCalls(stub func() (int, io.Reader, error)) {
	fake.nextReaderMutex.Lock()
	defer fake.nextReaderMutex.Unlock()
	fake.NextReaderStub = stub
}

func (fake *FakeConnection) NextReaderReturns(result1 int, result2 io.Reader, result3 error) {
	fake.nextReaderMutex.Lock()
	defer fake.nextReaderMutex.Unlock()
	fake.NextReaderStub = nil
	fake.nextReaderReturns = struct {
		result1 int
		result2 io.Reader
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeConnection) NextReaderReturnsOnCall(i int, result1 int, result2 io.Reader, result3 error) {
	fake.nextReaderMutex.Lock()
	defer fake.nextReaderMutex.Unlock()
	fake.NextReaderStub = nil
	if fake.nextReaderReturnsOnCall == nil {
		fake.nextReaderReturnsOnCall = make(map[int]struct {
			result1 int
			result2 io.Reader
			result3 error
		})
	}
	fake.nextReaderReturnsOnCall[i] = struct {
		result1 int
		result2 io.Reader
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeConnection) NextWriter(arg1 int) (io.WriteCloser, error) {
	fake.nextWriterMutex.Lock()
	ret, specificReturn := fake.nextWriterReturnsOnCall[len(fake.nextWriterArgsForCall)]
	fake.nextWriterArgsForCall = append(fake.nextWriterArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.NextWriterStub
	fakeReturns := fake.nextWriterReturns
	fake.recordInvocation("NextWriter", []interface{}{arg1})
	fake.nextWriterMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeConnection) NextWriterCallCount() int {
	fake.nextWriterMutex.RLock()
	defer fake.nextWriterMutex.RUnlock()
	return len(fake.nextWriterArgsForCall)
}

func (fake *FakeConnection) NextWriterCalls(stub func(int) (io.WriteCloser, error)) {
	fake.nextWriterMutex.Lock()
	defer fake.nextWriterMutex.Unlock()
	fake.NextWriterStub = stub
}

func (fake *FakeConnection) NextWriterArgsForCall(i int) int {
	fake.nextWriterMutex.RLock()
	defer fake.nextWriterMutex.RUnlock()
	argsForCall := fake.nextWriterArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeConnection) NextWriterReturns(result1 io.WriteCloser, result2 error) {
	fake.nextWriterMutex.Lock()
	defer fake.nextWriterMutex.Unlock()
	fake.NextWriterStub = nil
	fake.nextWriterReturns = struct {
		result1 io.WriteCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeConnection) NextWriterReturnsOnCall(i int, result1 io.WriteCloser, result2 error) {
	fake.nextWriterMutex.Lock()
	defer fake.nextWriterMutex.Unlock()
	fake.NextWriterStub = nil
	if fake.nextWriterReturnsOnCall == nil {
		fake.nextWriterReturnsOnCall = make(map[int]struct {
			result1 io.WriteCloser
			result2 error
		})
	}
	fake.nextWriterReturnsOnCall[i] = struct {
		result1 io.WriteCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeConnection) PingHandler() func(appData string) error {
	fake.pingHandlerMutex.Lock()
	ret, specificReturn := fake.pingHandlerReturnsOnCall[len(fake.pingHandlerArgsForCall)]
	fake.pingHandlerArgsForCall = append(fake.pingHandlerArgsForCall, struct {
	}{})
	stub := fake.PingHandlerStub
	fakeReturns := fake.pingHandlerReturns
	fake.recordInvocation("PingHandler", []interface{}{})
	fake.pingHandlerMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeConnection) PingHandlerCallCount() int {
	fake.pingHandlerMutex.RLock()
	defer fake.pingHandlerMutex.RUnlock()
	return len(fake.pingHandlerArgsForCall)
}

func (fake *FakeConnection) PingHandlerCalls(stub func() func(appData string) error) {
	fake.pingHandlerMutex.Lock()
	defer fake.pingHandlerMutex.Unlock()
	fake.PingHandlerStub = stub
}

func (fake *FakeConnection) PingHandlerReturns(result1 func(appData string) error) {
	fake.pingHandlerMutex.Lock()
	defer fake.pingHandlerMutex.Unlock()
	fake.PingHandlerStub = nil
	fake.pingHandlerReturns = struct {
		result1 func(appData string) error
	}{result1}
}

func (fake *FakeConnection) PingHandlerReturnsOnCall(i int, result1 func(appData string) error) {
	fake.pingHandlerMutex.Lock()
	defer fake.pingHandlerMutex.Unlock()
	fake.PingHandlerStub = nil
	if fake.pingHandlerReturnsOnCall == nil {
		fake.pingHandlerReturnsOnCall = make(map[int]struct {
			result1 func(appData string) error
		})
	}
	fake.pingHandlerReturnsOnCall[i] = struct {
		result1 func(appData string) error
	}{result1}
}

func (fake *FakeConnection) PongHandler() func(appData string) error {
	fake.pongHandlerMutex.Lock()
	ret, specificReturn := fake.pongHandlerReturnsOnCall[len(fake.pongHandlerArgsForCall)]
	fake.pongHandlerArgsForCall = append(fake.pongHandlerArgsForCall, struct {
	}{})
	stub := fake.PongHandlerStub
	fakeReturns := fake.pongHandlerReturns
	fake.recordInvocation("PongHandler", []interface{}{})
	fake.pongHandlerMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeConnection) PongHandlerCallCount() int {
	fake.pongHandlerMutex.RLock()
	defer fake.pongHandlerMutex.RUnlock()
	return len(fake.pongHandlerArgsForCall)
}

func (fake *FakeConnection) PongHandlerCalls(stub func() func(appData string) error) {
	fake.pongHandlerMutex.Lock()
	defer fake.pongHandlerMutex.Unlock()
	fake.PongHandlerStub = stub
}

func (fake *FakeConnection) PongHandlerReturns(result1 func(appData string) error) {
	fake.pongHandlerMutex.Lock()
	defer fake.pongHandlerMutex.Unlock()
	fake.PongHandlerStub = nil
	fake.pongHandlerReturns = struct {
		result1 func(appData string) error
	}{result1}
}

func (fake *FakeConnection) PongHandlerReturnsOnCall(i int, result1 func(appData string) error) {
	fake.pongHandlerMutex.Lock()
	defer fake.pongHandlerMutex.Unlock()
	fake.PongHandlerStub = nil
	if fake.pongHandlerReturnsOnCall == nil {
		fake.pongHandlerReturnsOnCall = make(map[int]struct {
			result1 func(appData string) error
		})
	}
	fake.pongHandlerReturnsOnCall[i] = struct {
		result1 func(appData string) error
	}{result1}
}

func (fake *FakeConnection) ReadHandler() ws.ReadHandler {
	fake.readHandlerMutex.Lock()
	ret, specificReturn := fake.readHandlerReturnsOnCall[len(fake.readHandlerArgsForCall)]
	fake.readHandlerArgsForCall = append(fake.readHandlerArgsForCall, struct {
	}{})
	stub := fake.ReadHandlerStub
	fakeReturns := fake.readHandlerReturns
	fake.recordInvocation("ReadHandler", []interface{}{})
	fake.readHandlerMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeConnection) ReadHandlerCallCount() int {
	fake.readHandlerMutex.RLock()
	defer fake.readHandlerMutex.RUnlock()
	return len(fake.readHandlerArgsForCall)
}

func (fake *FakeConnection) ReadHandlerCalls(stub func() ws.ReadHandler) {
	fake.readHandlerMutex.Lock()
	defer fake.readHandlerMutex.Unlock()
	fake.ReadHandlerStub = stub
}

func (fake *FakeConnection) ReadHandlerReturns(result1 ws.ReadHandler) {
	fake.readHandlerMutex.Lock()
	defer fake.readHandlerMutex.Unlock()
	fake.ReadHandlerStub = nil
	fake.readHandlerReturns = struct {
		result1 ws.ReadHandler
	}{result1}
}

func (fake *FakeConnection) ReadHandlerReturnsOnCall(i int, result1 ws.ReadHandler) {
	fake.readHandlerMutex.Lock()
	defer fake.readHandlerMutex.Unlock()
	fake.ReadHandlerStub = nil
	if fake.readHandlerReturnsOnCall == nil {
		fake.readHandlerReturnsOnCall = make(map[int]struct {
			result1 ws.ReadHandler
		})
	}
	fake.readHandlerReturnsOnCall[i] = struct {
		result1 ws.ReadHandler
	}{result1}
}

func (fake *FakeConnection) ReadMessage() (int, []byte, error) {
	fake.readMessageMutex.Lock()
	ret, specificReturn := fake.readMessageReturnsOnCall[len(fake.readMessageArgsForCall)]
	fake.readMessageArgsForCall = append(fake.readMessageArgsForCall, struct {
	}{})
	stub := fake.ReadMessageStub
	fakeReturns := fake.readMessageReturns
	fake.recordInvocation("ReadMessage", []interface{}{})
	fake.readMessageMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeConnection) ReadMessageCallCount() int {
	fake.readMessageMutex.RLock()
	defer fake.readMessageMutex.RUnlock()
	return len(fake.readMessageArgsForCall)
}

func (fake *FakeConnection) ReadMessageCalls(stub func() (int, []byte, error)) {
	fake.readMessageMutex.Lock()
	defer fake.readMessageMutex.Unlock()
	fake.ReadMessageStub = stub
}

func (fake *FakeConnection) ReadMessageReturns(result1 int, result2 []byte, result3 error) {
	fake.readMessageMutex.Lock()
	defer fake.readMessageMutex.Unlock()
	fake.ReadMessageStub = nil
	fake.readMessageReturns = struct {
		result1 int
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeConnection) ReadMessageReturnsOnCall(i int, result1 int, result2 []byte, result3 error) {
	fake.readMessageMutex.Lock()
	defer fake.readMessageMutex.Unlock()
	fake.ReadMessageStub = nil
	if fake.readMessageReturnsOnCall == nil {
		fake.readMessageReturnsOnCall = make(map[int]struct {
			result1 int
			result2 []byte
			result3 error
		})
	}
	fake.readMessageReturnsOnCall[i] = struct {
		result1 int
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeConnection) RemoteAddr() net.Addr {
	fake.remoteAddrMutex.Lock()
	ret, specificReturn := fake.remoteAddrReturnsOnCall[len(fake.remoteAddrArgsForCall)]
	fake.remoteAddrArgsForCall = append(fake.remoteAddrArgsForCall, struct {
	}{})
	stub := fake.RemoteAddrStub
	fakeReturns := fake.remoteAddrReturns
	fake.recordInvocation("RemoteAddr", []interface{}{})
	fake.remoteAddrMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeConnection) RemoteAddrCallCount() int {
	fake.remoteAddrMutex.RLock()
	defer fake.remoteAddrMutex.RUnlock()
	return len(fake.remoteAddrArgsForCall)
}

func (fake *FakeConnection) RemoteAddrCalls(stub func() net.Addr) {
	fake.remoteAddrMutex.Lock()
	defer fake.remoteAddrMutex.Unlock()
	fake.RemoteAddrStub = stub
}

func (fake *FakeConnection) RemoteAddrReturns(result1 net.Addr) {
	fake.remoteAddrMutex.Lock()
	defer fake.remoteAddrMutex.Unlock()
	fake.RemoteAddrStub = nil
	fake.remoteAddrReturns = struct {
		result1 net.Addr
	}{result1}
}

func (fake *FakeConnection) RemoteAddrReturnsOnCall(i int, result1 net.Addr) {
	fake.remoteAddrMutex.Lock()
	defer fake.remoteAddrMutex.Unlock()
	fake.RemoteAddrStub = nil
	if fake.remoteAddrReturnsOnCall == nil {
		fake.remoteAddrReturnsOnCall = make(map[int]struct {
			result1 net.Addr
		})
	}
	fake.remoteAddrReturnsOnCall[i] = struct {
		result1 net.Addr
	}{result1}
}

func (fake *FakeConnection) SetCloseHandler(arg1 func(code int, text string) error) {
	fake.setCloseHandlerMutex.Lock()
	fake.setCloseHandlerArgsForCall = append(fake.setCloseHandlerArgsForCall, struct {
		arg1 func(code int, text string) error
	}{arg1})
	stub := fake.SetCloseHandlerStub
	fake.recordInvocation("SetCloseHandler", []interface{}{arg1})
	fake.setCloseHandlerMutex.Unlock()
	if stub != nil {
		fake.SetCloseHandlerStub(arg1)
	}
}

func (fake *FakeConnection) SetCloseHandlerCallCount() int {
	fake.setCloseHandlerMutex.RLock()
	defer fake.setCloseHandlerMutex.RUnlock()
	return len(fake.setCloseHandlerArgsForCall)
}

func (fake *FakeConnection) SetCloseHandlerCalls(stub func(func(code int, text string) error)) {
	fake.setCloseHandlerMutex.Lock()
	defer fake.setCloseHandlerMutex.Unlock()
	fake.SetCloseHandlerStub = stub
}

func (fake *FakeConnection) SetCloseHandlerArgsForCall(i int) func(code int, text string) error {
	fake.setCloseHandlerMutex.RLock()
	defer fake.setCloseHandlerMutex.RUnlock()
	argsForCall := fake.setCloseHandlerArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeConnection) SetCompressionLevel(arg1 int) error {
	fake.setCompressionLevelMutex.Lock()
	ret, specificReturn := fake.setCompressionLevelReturnsOnCall[len(fake.setCompressionLevelArgsForCall)]
	fake.setCompressionLevelArgsForCall = append(fake.setCompressionLevelArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.SetCompressionLevelStub
	fakeReturns := fake.setCompressionLevelReturns
	fake.recordInvocation("SetCompressionLevel", []interface{}{arg1})
	fake.setCompressionLevelMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeConnection) SetCompressionLevelCallCount() int {
	fake.setCompressionLevelMutex.RLock()
	defer fake.setCompressionLevelMutex.RUnlock()
	return len(fake.setCompressionLevelArgsForCall)
}

func (fake *FakeConnection) SetCompressionLevelCalls(stub func(int) error) {
	fake.setCompressionLevelMutex.Lock()
	defer fake.setCompressionLevelMutex.Unlock()
	fake.SetCompressionLevelStub = stub
}

func (fake *FakeConnection) SetCompressionLevelArgsForCall(i int) int {
	fake.setCompressionLevelMutex.RLock()
	defer fake.setCompressionLevelMutex.RUnlock()
	argsForCall := fake.setCompressionLevelArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeConnection) SetCompressionLevelReturns(result1 error) {
	fake.setCompressionLevelMutex.Lock()
	defer fake.setCompressionLevelMutex.Unlock()
	fake.SetCompressionLevelStub = nil
	fake.setCompressionLevelReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeConnection) SetCompressionLevelReturnsOnCall(i int, result1 error) {
	fake.setCompressionLevelMutex.Lock()
	defer fake.setCompressionLevelMutex.Unlock()
	fake.SetCompressionLevelStub = nil
	if fake.setCompressionLevelReturnsOnCall == nil {
		fake.setCompressionLevelReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setCompressionLevelReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeConnection) SetPingHandler(arg1 func(appData string) error) {
	fake.setPingHandlerMutex.Lock()
	fake.setPingHandlerArgsForCall = append(fake.setPingHandlerArgsForCall, struct {
		arg1 func(appData string) error
	}{arg1})
	stub := fake.SetPingHandlerStub
	fake.recordInvocation("SetPingHandler", []interface{}{arg1})
	fake.setPingHandlerMutex.Unlock()
	if stub != nil {
		fake.SetPingHandlerStub(arg1)
	}
}

func (fake *FakeConnection) SetPingHandlerCallCount() int {
	fake.setPingHandlerMutex.RLock()
	defer fake.setPingHandlerMutex.RUnlock()
	return len(fake.setPingHandlerArgsForCall)
}

func (fake *FakeConnection) SetPingHandlerCalls(stub func(func(appData string) error)) {
	fake.setPingHandlerMutex.Lock()
	defer fake.setPingHandlerMutex.Unlock()
	fake.SetPingHandlerStub = stub
}

func (fake *FakeConnection) SetPingHandlerArgsForCall(i int) func(appData string) error {
	fake.setPingHandlerMutex.RLock()
	defer fake.setPingHandlerMutex.RUnlock()
	argsForCall := fake.setPingHandlerArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeConnection) SetPongHandler(arg1 func(appData string) error) {
	fake.setPongHandlerMutex.Lock()
	fake.setPongHandlerArgsForCall = append(fake.setPongHandlerArgsForCall, struct {
		arg1 func(appData string) error
	}{arg1})
	stub := fake.SetPongHandlerStub
	fake.recordInvocation("SetPongHandler", []interface{}{arg1})
	fake.setPongHandlerMutex.Unlock()
	if stub != nil {
		fake.SetPongHandlerStub(arg1)
	}
}

func (fake *FakeConnection) SetPongHandlerCallCount() int {
	fake.setPongHandlerMutex.RLock()
	defer fake.setPongHandlerMutex.RUnlock()
	return len(fake.setPongHandlerArgsForCall)
}

func (fake *FakeConnection) SetPongHandlerCalls(stub func(func(appData string) error)) {
	fake.setPongHandlerMutex.Lock()
	defer fake.setPongHandlerMutex.Unlock()
	fake.SetPongHandlerStub = stub
}

func (fake *FakeConnection) SetPongHandlerArgsForCall(i int) func(appData string) error {
	fake.setPongHandlerMutex.RLock()
	defer fake.setPongHandlerMutex.RUnlock()
	argsForCall := fake.setPongHandlerArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeConnection) SetReadDeadline(arg1 time.Time) error {
	fake.setReadDeadlineMutex.Lock()
	ret, specificReturn := fake.setReadDeadlineReturnsOnCall[len(fake.setReadDeadlineArgsForCall)]
	fake.setReadDeadlineArgsForCall = append(fake.setReadDeadlineArgsForCall, struct {
		arg1 time.Time
	}{arg1})
	stub := fake.SetReadDeadlineStub
	fakeReturns := fake.setReadDeadlineReturns
	fake.recordInvocation("SetReadDeadline", []interface{}{arg1})
	fake.setReadDeadlineMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeConnection) SetReadDeadlineCallCount() int {
	fake.setReadDeadlineMutex.RLock()
	defer fake.setReadDeadlineMutex.RUnlock()
	return len(fake.setReadDeadlineArgsForCall)
}

func (fake *FakeConnection) SetReadDeadlineCalls(stub func(time.Time) error) {
	fake.setReadDeadlineMutex.Lock()
	defer fake.setReadDeadlineMutex.Unlock()
	fake.SetReadDeadlineStub = stub
}

func (fake *FakeConnection) SetReadDeadlineArgsForCall(i int) time.Time {
	fake.setReadDeadlineMutex.RLock()
	defer fake.setReadDeadlineMutex.RUnlock()
	argsForCall := fake.setReadDeadlineArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeConnection) SetReadDeadlineReturns(result1 error) {
	fake.setReadDeadlineMutex.Lock()
	defer fake.setReadDeadlineMutex.Unlock()
	fake.SetReadDeadlineStub = nil
	fake.setReadDeadlineReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeConnection) SetReadDeadlineReturnsOnCall(i int, result1 error) {
	fake.setReadDeadlineMutex.Lock()
	defer fake.setReadDeadlineMutex.Unlock()
	fake.SetReadDeadlineStub = nil
	if fake.setReadDeadlineReturnsOnCall == nil {
		fake.setReadDeadlineReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setReadDeadlineReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeConnection) SetReadHandler(arg1 ws.ReadHandler) {
	fake.setReadHandlerMutex.Lock()
	fake.setReadHandlerArgsForCall = append(fake.setReadHandlerArgsForCall, struct {
		arg1 ws.ReadHandler
	}{arg1})
	stub := fake.SetReadHandlerStub
	fake.recordInvocation("SetReadHandler", []interface{}{arg1})
	fake.setReadHandlerMutex.Unlock()
	if stub != nil {
		fake.SetReadHandlerStub(arg1)
	}
}

func (fake *FakeConnection) SetReadHandlerCallCount() int {
	fake.setReadHandlerMutex.RLock()
	defer fake.setReadHandlerMutex.RUnlock()
	return len(fake.setReadHandlerArgsForCall)
}

func (fake *FakeConnection) SetReadHandlerCalls(stub func(ws.ReadHandler)) {
	fake.setReadHandlerMutex.Lock()
	defer fake.setReadHandlerMutex.Unlock()
	fake.SetReadHandlerStub = stub
}

func (fake *FakeConnection) SetReadHandlerArgsForCall(i int) ws.ReadHandler {
	fake.setReadHandlerMutex.RLock()
	defer fake.setReadHandlerMutex.RUnlock()
	argsForCall := fake.setReadHandlerArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeConnection) SetReadLimit(arg1 int64) {
	fake.setReadLimitMutex.Lock()
	fake.setReadLimitArgsForCall = append(fake.setReadLimitArgsForCall, struct {
		arg1 int64
	}{arg1})
	stub := fake.SetReadLimitStub
	fake.recordInvocation("SetReadLimit", []interface{}{arg1})
	fake.setReadLimitMutex.Unlock()
	if stub != nil {
		fake.SetReadLimitStub(arg1)
	}
}

func (fake *FakeConnection) SetReadLimitCallCount() int {
	fake.setReadLimitMutex.RLock()
	defer fake.setReadLimitMutex.RUnlock()
	return len(fake.setReadLimitArgsForCall)
}

func (fake *FakeConnection) SetReadLimitCalls(stub func(int64)) {
	fake.setReadLimitMutex.Lock()
	defer fake.setReadLimitMutex.Unlock()
	fake.SetReadLimitStub = stub
}

func (fake *FakeConnection) SetReadLimitArgsForCall(i int) int64 {
	fake.setReadLimitMutex.RLock()
	defer fake.setReadLimitMutex.RUnlock()
	argsForCall := fake.setReadLimitArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeConnection) SetWriteDeadline(arg1 time.Time) error {
	fake.setWriteDeadlineMutex.Lock()
	ret, specificReturn := fake.setWriteDeadlineReturnsOnCall[len(fake.setWriteDeadlineArgsForCall)]
	fake.setWriteDeadlineArgsForCall = append(fake.setWriteDeadlineArgsForCall, struct {
		arg1 time.Time
	}{arg1})
	stub := fake.SetWriteDeadlineStub
	fakeReturns := fake.setWriteDeadlineReturns
	fake.recordInvocation("SetWriteDeadline", []interface{}{arg1})
	fake.setWriteDeadlineMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeConnection) SetWriteDeadlineCallCount() int {
	fake.setWriteDeadlineMutex.RLock()
	defer fake.setWriteDeadlineMutex.RUnlock()
	return len(fake.setWriteDeadlineArgsForCall)
}

func (fake *FakeConnection) SetWriteDeadlineCalls(stub func(time.Time) error) {
	fake.setWriteDeadlineMutex.Lock()
	defer fake.setWriteDeadlineMutex.Unlock()
	fake.SetWriteDeadlineStub = stub
}

func (fake *FakeConnection) SetWriteDeadlineArgsForCall(i int) time.Time {
	fake.setWriteDeadlineMutex.RLock()
	defer fake.setWriteDeadlineMutex.RUnlock()
	argsForCall := fake.setWriteDeadlineArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeConnection) SetWriteDeadlineReturns(result1 error) {
	fake.setWriteDeadlineMutex.Lock()
	defer fake.setWriteDeadlineMutex.Unlock()
	fake.SetWriteDeadlineStub = nil
	fake.setWriteDeadlineReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeConnection) SetWriteDeadlineReturnsOnCall(i int, result1 error) {
	fake.setWriteDeadlineMutex.Lock()
	defer fake.setWriteDeadlineMutex.Unlock()
	fake.SetWriteDeadlineStub = nil
	if fake.setWriteDeadlineReturnsOnCall == nil {
		fake.setWriteDeadlineReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setWriteDeadlineReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeConnection) Subprotocol() string {
	fake.subprotocolMutex.Lock()
	ret, specificReturn := fake.subprotocolReturnsOnCall[len(fake.subprotocolArgsForCall)]
	fake.subprotocolArgsForCall = append(fake.subprotocolArgsForCall, struct {
	}{})
	stub := fake.SubprotocolStub
	fakeReturns := fake.subprotocolReturns
	fake.recordInvocation("Subprotocol", []interface{}{})
	fake.subprotocolMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeConnection) SubprotocolCallCount() int {
	fake.subprotocolMutex.RLock()
	defer fake.subprotocolMutex.RUnlock()
	return len(fake.subprotocolArgsForCall)
}

func (fake *FakeConnection) SubprotocolCalls(stub func() string) {
	fake.subprotocolMutex.Lock()
	defer fake.subprotocolMutex.Unlock()
	fake.SubprotocolStub = stub
}

func (fake *FakeConnection) SubprotocolReturns(result1 string) {
	fake.subprotocolMutex.Lock()
	defer fake.subprotocolMutex.Unlock()
	fake.SubprotocolStub = nil
	fake.subprotocolReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeConnection) SubprotocolReturnsOnCall(i int, result1 string) {
	fake.subprotocolMutex.Lock()
	defer fake.subprotocolMutex.Unlock()
	fake.SubprotocolStub = nil
	if fake.subprotocolReturnsOnCall == nil {
		fake.subprotocolReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.subprotocolReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeConnection) UnderlyingConn() net.Conn {
	fake.underlyingConnMutex.Lock()
	ret, specificReturn := fake.underlyingConnReturnsOnCall[len(fake.underlyingConnArgsForCall)]
	fake.underlyingConnArgsForCall = append(fake.underlyingConnArgsForCall, struct {
	}{})
	stub := fake.UnderlyingConnStub
	fakeReturns := fake.underlyingConnReturns
	fake.recordInvocation("UnderlyingConn", []interface{}{})
	fake.underlyingConnMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeConnection) UnderlyingConnCallCount() int {
	fake.underlyingConnMutex.RLock()
	defer fake.underlyingConnMutex.RUnlock()
	return len(fake.underlyingConnArgsForCall)
}

func (fake *FakeConnection) UnderlyingConnCalls(stub func() net.Conn) {
	fake.underlyingConnMutex.Lock()
	defer fake.underlyingConnMutex.Unlock()
	fake.UnderlyingConnStub = stub
}

func (fake *FakeConnection) UnderlyingConnReturns(result1 net.Conn) {
	fake.underlyingConnMutex.Lock()
	defer fake.underlyingConnMutex.Unlock()
	fake.UnderlyingConnStub = nil
	fake.underlyingConnReturns = struct {
		result1 net.Conn
	}{result1}
}

func (fake *FakeConnection) UnderlyingConnReturnsOnCall(i int, result1 net.Conn) {
	fake.underlyingConnMutex.Lock()
	defer fake.underlyingConnMutex.Unlock()
	fake.UnderlyingConnStub = nil
	if fake.underlyingConnReturnsOnCall == nil {
		fake.underlyingConnReturnsOnCall = make(map[int]struct {
			result1 net.Conn
		})
	}
	fake.underlyingConnReturnsOnCall[i] = struct {
		result1 net.Conn
	}{result1}
}

func (fake *FakeConnection) Write(arg1 []byte) (int, error) {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.writeMutex.Lock()
	ret, specificReturn := fake.writeReturnsOnCall[len(fake.writeArgsForCall)]
	fake.writeArgsForCall = append(fake.writeArgsForCall, struct {
		arg1 []byte
	}{arg1Copy})
	stub := fake.WriteStub
	fakeReturns := fake.writeReturns
	fake.recordInvocation("Write", []interface{}{arg1Copy})
	fake.writeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeConnection) WriteCallCount() int {
	fake.writeMutex.RLock()
	defer fake.writeMutex.RUnlock()
	return len(fake.writeArgsForCall)
}

func (fake *FakeConnection) WriteCalls(stub func([]byte) (int, error)) {
	fake.writeMutex.Lock()
	defer fake.writeMutex.Unlock()
	fake.WriteStub = stub
}

func (fake *FakeConnection) WriteArgsForCall(i int) []byte {
	fake.writeMutex.RLock()
	defer fake.writeMutex.RUnlock()
	argsForCall := fake.writeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeConnection) WriteReturns(result1 int, result2 error) {
	fake.writeMutex.Lock()
	defer fake.writeMutex.Unlock()
	fake.WriteStub = nil
	fake.writeReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeConnection) WriteReturnsOnCall(i int, result1 int, result2 error) {
	fake.writeMutex.Lock()
	defer fake.writeMutex.Unlock()
	fake.WriteStub = nil
	if fake.writeReturnsOnCall == nil {
		fake.writeReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.writeReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeConnection) WriteControl(arg1 int, arg2 []byte, arg3 time.Time) error {
	var arg2Copy []byte
	if arg2 != nil {
		arg2Copy = make([]byte, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.writeControlMutex.Lock()
	ret, specificReturn := fake.writeControlReturnsOnCall[len(fake.writeControlArgsForCall)]
	fake.writeControlArgsForCall = append(fake.writeControlArgsForCall, struct {
		arg1 int
		arg2 []byte
		arg3 time.Time
	}{arg1, arg2Copy, arg3})
	stub := fake.WriteControlStub
	fakeReturns := fake.writeControlReturns
	fake.recordInvocation("WriteControl", []interface{}{arg1, arg2Copy, arg3})
	fake.writeControlMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeConnection) WriteControlCallCount() int {
	fake.writeControlMutex.RLock()
	defer fake.writeControlMutex.RUnlock()
	return len(fake.writeControlArgsForCall)
}

func (fake *FakeConnection) WriteControlCalls(stub func(int, []byte, time.Time) error) {
	fake.writeControlMutex.Lock()
	defer fake.writeControlMutex.Unlock()
	fake.WriteControlStub = stub
}

func (fake *FakeConnection) WriteControlArgsForCall(i int) (int, []byte, time.Time) {
	fake.writeControlMutex.RLock()
	defer fake.writeControlMutex.RUnlock()
	argsForCall := fake.writeControlArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeConnection) WriteControlReturns(result1 error) {
	fake.writeControlMutex.Lock()
	defer fake.writeControlMutex.Unlock()
	fake.WriteControlStub = nil
	fake.writeControlReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeConnection) WriteControlReturnsOnCall(i int, result1 error) {
	fake.writeControlMutex.Lock()
	defer fake.writeControlMutex.Unlock()
	fake.WriteControlStub = nil
	if fake.writeControlReturnsOnCall == nil {
		fake.writeControlReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.writeControlReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeConnection) WriteMessage(arg1 int, arg2 []byte) error {
	var arg2Copy []byte
	if arg2 != nil {
		arg2Copy = make([]byte, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.writeMessageMutex.Lock()
	ret, specificReturn := fake.writeMessageReturnsOnCall[len(fake.writeMessageArgsForCall)]
	fake.writeMessageArgsForCall = append(fake.writeMessageArgsForCall, struct {
		arg1 int
		arg2 []byte
	}{arg1, arg2Copy})
	stub := fake.WriteMessageStub
	fakeReturns := fake.writeMessageReturns
	fake.recordInvocation("WriteMessage", []interface{}{arg1, arg2Copy})
	fake.writeMessageMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeConnection) WriteMessageCallCount() int {
	fake.writeMessageMutex.RLock()
	defer fake.writeMessageMutex.RUnlock()
	return len(fake.writeMessageArgsForCall)
}

func (fake *FakeConnection) WriteMessageCalls(stub func(int, []byte) error) {
	fake.writeMessageMutex.Lock()
	defer fake.writeMessageMutex.Unlock()
	fake.WriteMessageStub = stub
}

func (fake *FakeConnection) WriteMessageArgsForCall(i int) (int, []byte) {
	fake.writeMessageMutex.RLock()
	defer fake.writeMessageMutex.RUnlock()
	argsForCall := fake.writeMessageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeConnection) WriteMessageReturns(result1 error) {
	fake.writeMessageMutex.Lock()
	defer fake.writeMessageMutex.Unlock()
	fake.WriteMessageStub = nil
	fake.writeMessageReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeConnection) WriteMessageReturnsOnCall(i int, result1 error) {
	fake.writeMessageMutex.Lock()
	defer fake.writeMessageMutex.Unlock()
	fake.WriteMessageStub = nil
	if fake.writeMessageReturnsOnCall == nil {
		fake.writeMessageReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.writeMessageReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeConnection) WritePreparedMessage(arg1 *websocket.PreparedMessage) error {
	fake.writePreparedMessageMutex.Lock()
	ret, specificReturn := fake.writePreparedMessageReturnsOnCall[len(fake.writePreparedMessageArgsForCall)]
	fake.writePreparedMessageArgsForCall = append(fake.writePreparedMessageArgsForCall, struct {
		arg1 *websocket.PreparedMessage
	}{arg1})
	stub := fake.WritePreparedMessageStub
	fakeReturns := fake.writePreparedMessageReturns
	fake.recordInvocation("WritePreparedMessage", []interface{}{arg1})
	fake.writePreparedMessageMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeConnection) WritePreparedMessageCallCount() int {
	fake.writePreparedMessageMutex.RLock()
	defer fake.writePreparedMessageMutex.RUnlock()
	return len(fake.writePreparedMessageArgsForCall)
}

func (fake *FakeConnection) WritePreparedMessageCalls(stub func(*websocket.PreparedMessage) error) {
	fake.writePreparedMessageMutex.Lock()
	defer fake.writePreparedMessageMutex.Unlock()
	fake.WritePreparedMessageStub = stub
}

func (fake *FakeConnection) WritePreparedMessageArgsForCall(i int) *websocket.PreparedMessage {
	fake.writePreparedMessageMutex.RLock()
	defer fake.writePreparedMessageMutex.RUnlock()
	argsForCall := fake.writePreparedMessageArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeConnection) WritePreparedMessageReturns(result1 error) {
	fake.writePreparedMessageMutex.Lock()
	defer fake.writePreparedMessageMutex.Unlock()
	fake.WritePreparedMessageStub = nil
	fake.writePreparedMessageReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeConnection) WritePreparedMessageReturnsOnCall(i int, result1 error) {
	fake.writePreparedMessageMutex.Lock()
	defer fake.writePreparedMessageMutex.Unlock()
	fake.WritePreparedMessageStub = nil
	if fake.writePreparedMessageReturnsOnCall == nil {
		fake.writePreparedMessageReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.writePreparedMessageReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeConnection) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	fake.closeHandlerMutex.RLock()
	defer fake.closeHandlerMutex.RUnlock()
	fake.closeWithMsgMutex.RLock()
	defer fake.closeWithMsgMutex.RUnlock()
	fake.closedMutex.RLock()
	defer fake.closedMutex.RUnlock()
	fake.enableWriteCompressionMutex.RLock()
	defer fake.enableWriteCompressionMutex.RUnlock()
	fake.listenMutex.RLock()
	defer fake.listenMutex.RUnlock()
	fake.localAddrMutex.RLock()
	defer fake.localAddrMutex.RUnlock()
	fake.nextReaderMutex.RLock()
	defer fake.nextReaderMutex.RUnlock()
	fake.nextWriterMutex.RLock()
	defer fake.nextWriterMutex.RUnlock()
	fake.pingHandlerMutex.RLock()
	defer fake.pingHandlerMutex.RUnlock()
	fake.pongHandlerMutex.RLock()
	defer fake.pongHandlerMutex.RUnlock()
	fake.readHandlerMutex.RLock()
	defer fake.readHandlerMutex.RUnlock()
	fake.readMessageMutex.RLock()
	defer fake.readMessageMutex.RUnlock()
	fake.remoteAddrMutex.RLock()
	defer fake.remoteAddrMutex.RUnlock()
	fake.setCloseHandlerMutex.RLock()
	defer fake.setCloseHandlerMutex.RUnlock()
	fake.setCompressionLevelMutex.RLock()
	defer fake.setCompressionLevelMutex.RUnlock()
	fake.setPingHandlerMutex.RLock()
	defer fake.setPingHandlerMutex.RUnlock()
	fake.setPongHandlerMutex.RLock()
	defer fake.setPongHandlerMutex.RUnlock()
	fake.setReadDeadlineMutex.RLock()
	defer fake.setReadDeadlineMutex.RUnlock()
	fake.setReadHandlerMutex.RLock()
	defer fake.setReadHandlerMutex.RUnlock()
	fake.setReadLimitMutex.RLock()
	defer fake.setReadLimitMutex.RUnlock()
	fake.setWriteDeadlineMutex.RLock()
	defer fake.setWriteDeadlineMutex.RUnlock()
	fake.subprotocolMutex.RLock()
	defer fake.subprotocolMutex.RUnlock()
	fake.underlyingConnMutex.RLock()
	defer fake.underlyingConnMutex.RUnlock()
	fake.writeMutex.RLock()
	defer fake.writeMutex.RUnlock()
	fake.writeControlMutex.RLock()
	defer fake.writeControlMutex.RUnlock()
	fake.writeMessageMutex.RLock()
	defer fake.writeMessageMutex.RUnlock()
	fake.writePreparedMessageMutex.RLock()
	defer fake.writePreparedMessageMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeConnection) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ ws.Connection = new(FakeConnection)
